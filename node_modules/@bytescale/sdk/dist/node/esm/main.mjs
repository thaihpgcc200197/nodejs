import * as __WEBPACK_EXTERNAL_MODULE_stream__ from "stream";
import * as __WEBPACK_EXTERNAL_MODULE_buffer__ from "buffer";
/******/ // The require scope
/******/ var __lib_require__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ !function() {
/******/ 	// define getter functions for harmony exports
/******/ 	__lib_require__.d = function(exports, definition) {
/******/ 		for(var key in definition) {
/******/ 			if(__lib_require__.o(definition, key) && !__lib_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ }();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ !function() {
/******/ 	__lib_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ }();
/******/ 
/************************************************************************/
var __lib_exports__ = {};

// EXPORTS
__lib_require__.d(__lib_exports__, {
  AuthManager: function() { return /* reexport */ AuthManager; },
  BaseAPI: function() { return /* reexport */ BaseAPI; },
  BinaryResult: function() { return /* reexport */ BinaryResult; },
  BytescaleApiClientConfigUtils: function() { return /* reexport */ BytescaleApiClientConfigUtils; },
  BytescaleApiError: function() { return /* reexport */ BytescaleApiError; },
  BytescaleGenericError: function() { return /* reexport */ BytescaleGenericError; },
  CacheApi: function() { return /* reexport */ CacheApi; },
  CancelledError: function() { return /* reexport */ CancelledError; },
  CommonTypesNoOp: function() { return /* reexport */ CommonTypesNoOp; },
  FileApi: function() { return /* reexport */ FileApi; },
  FolderApi: function() { return /* reexport */ FolderApi; },
  JSONApiResponse: function() { return /* reexport */ JSONApiResponse; },
  JobApi: function() { return /* reexport */ JobApi; },
  UploadApi: function() { return /* reexport */ UploadApi; },
  UploadManager: function() { return /* reexport */ UploadManager; },
  UrlBuilder: function() { return /* reexport */ UrlBuilder; },
  UrlBuilderTypesNoOp: function() { return /* reexport */ UrlBuilderTypesNoOp; },
  VoidApiResponse: function() { return /* reexport */ VoidApiResponse; },
  encodeBytescaleQuerystringKVP: function() { return /* reexport */ encodeBytescaleQuerystringKVP; },
  querystring: function() { return /* reexport */ querystring; }
});

;// CONCATENATED MODULE: ./src/private/FairMutex.ts
function _call(body, then, direct) {
  if (direct) {
    return then ? then(body()) : body();
  }
  try {
    var result = Promise.resolve(body());
    return then ? result.then(then) : result;
  } catch (e) {
    return Promise.reject(e);
  }
}
function _rethrow(thrown, value) {
  if (thrown) throw value;
  return value;
}
function _finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }
  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }
  return finalizer(false, result);
}
function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function _empty() {}
function _awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(_empty) : Promise.resolve();
  }
}
function _invoke(body, then) {
  var result = body();
  if (result && result.then) {
    return result.then(then);
  }
  return then(result);
}
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * A lightweight fair mutex. (Other libraries contain too many features and we want to keep size down).
 *
 * Characteristics:
 * - Non-reentrant.
 * - Fair.
 *   - This means multiple callers awaiting 'lock' will be granted the mutex in the order they requested it.
 *   - This is important, as in React, developers calling 'AuthManager.endAuthSession' in a 'useEffect' cleanup need it
 *     to take effect immediately, such that subsequent 'AuthManager.beginAuthSession' calls will always succeed.
 *   - When calling `safe` consecutively with no 'awaits' in-between, the current context will synchronously acquire
 *     the mutex every time.
 */
var FairMutex = /*#__PURE__*/function () {
  function FairMutex() {
    _classCallCheck(this, FairMutex);
    this.locked = false;
    this.queue = [];
  }
  return _createClass(FairMutex, [{
    key: "safe",
    value: function safe(callback) {
      try {
        var _this = this;
        return _await(_this.lock(), function () {
          return _finallyRethrows(callback, function (_wasThrown, _result) {
            _this.unlock();
            return _rethrow(_wasThrown, _result);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "lock",
    value: function lock() {
      try {
        var _exit = false;
        var _this2 = this;
        return _await(_invoke(function () {
          if (_this2.locked) {
            var unlockNext;
            var lockPromise = new Promise(function (resolve) {
              unlockNext = resolve;
            });
            if (unlockNext === undefined) {
              throw new Error("unlockNext was undefined");
            }
            _this2.queue.push({
              resolve: unlockNext
            });
            return _awaitIgnored(lockPromise);
          }
        }, function (_result2) {
          if (_exit) return _result2;
          _this2.locked = true;
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "unlock",
    value: function unlock() {
      if (!this.locked) {
        throw new Error("Mutex is not locked.");
      }
      var nextInQueue = this.queue.shift();
      if (nextInQueue !== undefined) {
        nextInQueue.resolve();
      } else {
        this.locked = false;
      }
    }
  }]);
}();
;// CONCATENATED MODULE: ./src/private/AuthSessionState.ts
function AuthSessionState_typeof(o) { "@babel/helpers - typeof"; return AuthSessionState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, AuthSessionState_typeof(o); }
function AuthSessionState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function AuthSessionState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, AuthSessionState_toPropertyKey(descriptor.key), descriptor); } }
function AuthSessionState_createClass(Constructor, protoProps, staticProps) { if (protoProps) AuthSessionState_defineProperties(Constructor.prototype, protoProps); if (staticProps) AuthSessionState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function AuthSessionState_toPropertyKey(t) { var i = AuthSessionState_toPrimitive(t, "string"); return "symbol" == AuthSessionState_typeof(i) ? i : i + ""; }
function AuthSessionState_toPrimitive(t, r) { if ("object" != AuthSessionState_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != AuthSessionState_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

/**
 * Maintains a global session state, even across package versions.
 *
 * This is to allow users to start auth sessions via the Bytescale JavaScript SDK, where due to versioning or other
 * bundling issues, the Bytescale Upload Widget has been bundled with a different Bytescale JavaScript SDK. In this
 * scenario, the user wouldn't be able to start an auth session with the Bytescale Upload Widget. Therefore, we use
 * global state (i.e. on the window) to ensure the session state can be shared between the user's instance of the
 * Bytescale JavaScript SDK and the Upload Widget's version of the Bytescale JavaScript SDK.
 *
 * Users also frequently have problems caused by them not keeping track of *Api and *Manager instances correctly, so
 * making this global prevents a lot of common mistakes.
 */
var AuthSessionState = /*#__PURE__*/function () {
  function AuthSessionState() {
    AuthSessionState_classCallCheck(this, AuthSessionState);
  }
  return AuthSessionState_createClass(AuthSessionState, null, [{
    key: "getMutex",
    value:
    /**
     * Called in the browser only.
     */
    function getMutex() {
      var key = AuthSessionState.mutexKey;
      var mutex = window[key];
      if (mutex === undefined) {
        mutex = new FairMutex();
        window[key] = mutex;
      }
      return mutex;
    }
    /**
     * Called in the browser only.
     */
  }, {
    key: "setSession",
    value: function setSession(session) {
      window[AuthSessionState.stateKey] = session;
    }
    /**
     * Called in the browser and in Node.js (so we check the env before calling env-specific code).
     */
  }, {
    key: "getSession",
    value: function getSession() {
      if (typeof window === "undefined") {
        return undefined;
      }
      return window[AuthSessionState.stateKey];
    }
  }]);
}();
AuthSessionState.stateKey = "BytescaleSessionState";
AuthSessionState.mutexKey = "BytescaleSessionStateMutex";
;// CONCATENATED MODULE: ./src/private/ConsoleUtils.ts
function ConsoleUtils_typeof(o) { "@babel/helpers - typeof"; return ConsoleUtils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, ConsoleUtils_typeof(o); }
function ConsoleUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function ConsoleUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, ConsoleUtils_toPropertyKey(descriptor.key), descriptor); } }
function ConsoleUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) ConsoleUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) ConsoleUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function ConsoleUtils_toPropertyKey(t) { var i = ConsoleUtils_toPrimitive(t, "string"); return "symbol" == ConsoleUtils_typeof(i) ? i : i + ""; }
function ConsoleUtils_toPrimitive(t, r) { if ("object" != ConsoleUtils_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != ConsoleUtils_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var ConsoleUtils = /*#__PURE__*/function () {
  function ConsoleUtils() {
    ConsoleUtils_classCallCheck(this, ConsoleUtils);
  }
  return ConsoleUtils_createClass(ConsoleUtils, null, [{
    key: "debug",
    value: function debug(message) {
      console.log(ConsoleUtils.prefix(message));
    }
  }, {
    key: "warn",
    value: function warn(message) {
      console.warn(ConsoleUtils.prefix(message));
    }
  }, {
    key: "error",
    value: function error(message) {
      console.error(ConsoleUtils.prefix(message));
    }
  }, {
    key: "prefix",
    value: function prefix(message) {
      return "[bytescale-sdk] ".concat(message);
    }
  }]);
}();
;// CONCATENATED MODULE: ./src/public/shared/generated/runtime.ts
function runtime_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function runtime_empty() {}
function _continue(value, then) {
  return value && value.then ? value.then(then) : then(value);
}
function runtime_invoke(body, then) {
  var result = body();
  if (result && result.then) {
    return result.then(then);
  }
  return then(result);
}
function runtime_typeof(o) { "@babel/helpers - typeof"; return runtime_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, runtime_typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (runtime_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = runtime_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function runtime_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function runtime_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, runtime_toPropertyKey(descriptor.key), descriptor); } }
function runtime_createClass(Constructor, protoProps, staticProps) { if (protoProps) runtime_defineProperties(Constructor.prototype, protoProps); if (staticProps) runtime_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function runtime_toPropertyKey(t) { var i = runtime_toPrimitive(t, "string"); return "symbol" == runtime_typeof(i) ? i : i + ""; }
function runtime_toPrimitive(t, r) { if ("object" != runtime_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != runtime_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var BytescaleApiClientConfigUtils = /*#__PURE__*/function () {
  function BytescaleApiClientConfigUtils() {
    runtime_classCallCheck(this, BytescaleApiClientConfigUtils);
  }
  return runtime_createClass(BytescaleApiClientConfigUtils, null, [{
    key: "getApiUrl",
    value: function getApiUrl(config) {
      var _a;
      return (_a = config.apiUrl) !== null && _a !== void 0 ? _a : BytescaleApiClientConfigUtils.defaultApiUrl;
    }
  }, {
    key: "getCdnUrl",
    value: function getCdnUrl(config) {
      var _a;
      return (_a = config.cdnUrl) !== null && _a !== void 0 ? _a : BytescaleApiClientConfigUtils.defaultCdnUrl;
    }
  }, {
    key: "getFetchApi",
    value: function getFetchApi(config) {
      var _a;
      return (_a = config.fetchApi) !== null && _a !== void 0 ? _a : fetch;
    }
  }, {
    key: "getAccountId",
    value: function getAccountId(config) {
      var _a, _b;
      var accountId;
      if (BytescaleApiClientConfigUtils.specialApiKeys.includes(config.apiKey)) {
        accountId = BytescaleApiClientConfigUtils.specialApiKeyAccountId;
      } else {
        accountId = (_b = (_a = config.apiKey.split("_")[1]) === null || _a === void 0 ? void 0 : _a.substr(0, BytescaleApiClientConfigUtils.accountIdLength)) !== null && _b !== void 0 ? _b : "";
        if (accountId.length !== BytescaleApiClientConfigUtils.accountIdLength) {
          throw new Error("Invalid Bytescale API key.");
        }
      }
      return accountId;
    }
  }, {
    key: "validate",
    value: function validate(config) {
      var _a;
      // Defensive programming, for users not using TypeScript. Mainly because this is used by UploadWidget users.
      if ((config !== null && config !== void 0 ? config : undefined) === undefined) {
        throw new Error("Config parameter required.");
      }
      if (((_a = config.apiKey) !== null && _a !== void 0 ? _a : undefined) === undefined) {
        throw new Error("Please provide an API key via the 'apiKey' config parameter.");
      }
      if (config.apiKey.trim() !== config.apiKey) {
        // We do not support API keys with whitespace (by trimming ourselves) because otherwise we'd need to support this
        // everywhere in perpetuity (since removing the trimming would be a breaking change).
        throw new Error("API key needs trimming (whitespace detected).");
      }
      // This performs futher validation on the API key...
      BytescaleApiClientConfigUtils.getAccountId(config);
    }
  }]);
}();
BytescaleApiClientConfigUtils.defaultApiUrl = "https://api.bytescale.com";
BytescaleApiClientConfigUtils.defaultCdnUrl = "https://upcdn.io";
BytescaleApiClientConfigUtils.specialApiKeys = ["free", "demo"];
BytescaleApiClientConfigUtils.specialApiKeyAccountId = "W142hJk";
BytescaleApiClientConfigUtils.accountIdLength = 7; // Sync with: upload/shared/**/AccountIdUtils
/**
 * This is the base class for all generated API classes.
 */
var BaseAPI = /*#__PURE__*/function () {
  function BaseAPI(config) {
    runtime_classCallCheck(this, BaseAPI);
    this.config = config;
    BytescaleApiClientConfigUtils.validate(config);
  }
  /**
   * Returns a successful response (2**) else throws an error.
   */
  return runtime_createClass(BaseAPI, [{
    key: "request",
    value: function request(context, initOverrides, baseUrlOverride) {
      try {
        var _this = this;
        var _a;
        var apiKey = _this.config.apiKey;
        context.headers["Authorization"] = "Bearer ".concat(apiKey); // authorization-header authentication
        var session = AuthSessionState.getSession();
        if ((session === null || session === void 0 ? void 0 : session.accessToken) !== undefined) {
          context.headers["Authorization-Token"] = session.accessToken;
        }
        // Key: any possible value for 'baseUrlOverride'
        // Value: user-overridden value for that base URL from the config.
        var nonDefaultBasePaths = _defineProperty({}, BytescaleApiClientConfigUtils.defaultCdnUrl, BytescaleApiClientConfigUtils.getCdnUrl(_this.config));
        return runtime_await(_this.createFetchParams(context, initOverrides, baseUrlOverride === undefined ? undefined : (_a = nonDefaultBasePaths[baseUrlOverride]) !== null && _a !== void 0 ? _a : baseUrlOverride), function (_ref) {
          var url = _ref.url,
            init = _ref.init;
          return BaseAPI.fetch(url, init, Object.assign(Object.assign({}, _this.config), {
            isBytescaleApi: true
          }));
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "encodeParam",
    value: function encodeParam(paramName, paramValue) {
      if (paramName === "filePath") {
        if (!paramValue.startsWith("/")) {
          // Non-obvious errors are returned by the Bytescale CDN if forward slashes are omitted, so catch it client-side:
          throw new Error("The 'filePath' parameter must begin with a '/' character.");
        }
        // We must not encode the filePath param (as slashes are valid).
        return paramValue;
      }
      return encodeURIComponent(paramValue);
    }
  }, {
    key: "createFetchParams",
    value: function createFetchParams(context, initOverrides, baseUrlOverride) {
      try {
        var _this2 = this;
        var url = (baseUrlOverride !== null && baseUrlOverride !== void 0 ? baseUrlOverride : BytescaleApiClientConfigUtils.getApiUrl(_this2.config)) + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
          // only add the querystring to the URL if there are query parameters.
          // this is done to avoid urls ending with a "?" character which buggy webservers
          // do not handle correctly sometimes.
          url += "?" + querystring(context.query);
        }
        var configHeaders = _this2.config.headers;
        var _Object$assign = Object.assign({}, context.headers);
        return runtime_await(runtime_await(configHeaders === undefined ? {} : typeof configHeaders === "function" ? configHeaders() : configHeaders, function (_configHeaders) {
          var headers = Object.assign(_Object$assign, configHeaders === undefined ? _configHeaders : _configHeaders);
          Object.keys(headers).forEach(function (key) {
            return headers[key] === undefined ? delete headers[key] : {};
          });
          var initOverrideFn = typeof initOverrides === "function" ? initOverrides : function () {
            return runtime_await(initOverrides);
          };
          var initParams = {
            method: context.method,
            headers: headers,
            body: context.body
          };
          var _Object$assign2 = Object.assign({}, initParams);
          return runtime_await(initOverrideFn({
            init: initParams,
            context: context
          }), function (_initOverrideFn) {
            var overriddenInit = Object.assign(_Object$assign2, _initOverrideFn);
            var init = Object.assign(Object.assign({}, overriddenInit), {
              body: JSON.stringify(overriddenInit.body)
            });
            return {
              url: url,
              init: init
            };
          });
        }, configHeaders === undefined || !(typeof configHeaders === "function")));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }], [{
    key: "fetch",
    value: function fetch(url, init, config) {
      try {
        var _exit = false;
        var _a, _b;
        var response;
        return runtime_await(_continue(_catch(function () {
          return runtime_await(BytescaleApiClientConfigUtils.getFetchApi(config)(url, Object.assign(Object.assign({}, init), {
            // This is specifically added to cater for Next.js's Fetch implementation, which caches POST requests...
            //
            // "fetch requests that use the POST method are also automatically cached."
            // - https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#caching-data
            //
            // However, this is probably a good idea, even for all GET requests, as if the user is refreshing a JWT
            // or downloading a file via 'FileApi.downloadFile', then they'll likely want the latest.
            cache: "no-store"
          })), function (_BytescaleApiClientCo) {
            response = _BytescaleApiClientCo;
          });
        }, function (e) {
          // Network-level errors, CORS errors, or HTTP-level errors from intermediary services (e.g. AWS or the user's own infrastructure/proxies).
          // HTTP-level errors from external services (e.g. AWS or the user's own proxy) will appear as CORS errors as their response headers won't include the appropriate CORS values.
          throw new Error(config.isBytescaleApi ? "Unable to resolve the Bytescale API: ".concat(e.message, " If the problem persists, and your network connection is OK, then please contact support@bytescale.com and provide: (a) time of failed request in UTC (b) screenshot of failed network response header + body (c) screenshot of failed network request header + body (d) browser and OS version.") : "Unable to resolve URL (".concat(url, "): ").concat(e.message));
        }), function (_result) {
          var _exit2 = false;
          if (_exit) return _result;
          return response.status >= 200 && response.status < 300 ? response : runtime_invoke(function () {
            if (config.isBytescaleApi) {
              var errorText = undefined;
              var errorJson = undefined;
              return _continue(_catch(function () {
                return runtime_await(response.text(), function (_response$text) {
                  errorText = _response$text;
                  errorJson = JSON.parse(errorText);
                });
              }, runtime_empty), function () {
                if (typeof ((_a = errorJson === null || errorJson === void 0 ? void 0 : errorJson.error) === null || _a === void 0 ? void 0 : _a.code) === "string") {
                  throw new BytescaleApiError(errorJson);
                }
                if (config.debug === true) {
                  ConsoleUtils.debug("Error response header:");
                  response.headers.forEach(function (headerValue, headerKey) {
                    return ConsoleUtils.debug("".concat(headerKey, ": ").concat(headerValue));
                  });
                  ConsoleUtils.debug("Error response body:");
                  ConsoleUtils.debug(errorText !== null && errorText !== void 0 ? errorText : "<empty>");
                }
                // HTTP-level errors from intermediary services (e.g. AWS or the user's own infrastructure/proxies). On the browser,
                // this error is unlikely to be triggered since these errors will masqurade as CORS errors (see above) but in Node.js
                // this error will appear from any intermediary service failure. Also occurs when calling ProcessFile for an
                // asynchronous media job, where the transformation is initiated using the primary artifact: in this instance,
                // a 404 JSON response is returned containing the transformation job until it completes.
                throw new BytescaleGenericError(response, errorText, errorJson);
              });
            }
          }, function (_result2) {
            if (_exit2) return _result2;
            throw new Error("Failure status code (".concat(response.status, ") received for request: ").concat((_b = init.method) !== null && _b !== void 0 ? _b : "GET", " ").concat(url));
          });
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}();
var CancelledError = /*#__PURE__*/function (_Error) {
  function CancelledError() {
    var _this3;
    runtime_classCallCheck(this, CancelledError);
    _this3 = _callSuper(this, CancelledError, ["Operation cancelled by caller."]);
    _this3.name = "CancelledError";
    return _this3;
  }
  _inherits(CancelledError, _Error);
  return runtime_createClass(CancelledError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Thrown when the Bytescale API cannot be reached or when an error is returned that cannot be parsed as a JSON error response.
 */
var BytescaleGenericError = /*#__PURE__*/function (_Error2) {
  function BytescaleGenericError(response, responseText, responseJson) {
    var _this4;
    runtime_classCallCheck(this, BytescaleGenericError);
    _this4 = _callSuper(this, BytescaleGenericError, ["Unable to connect to the Bytescale API (".concat(response.status, "): please try again.")]);
    _this4.response = response;
    _this4.responseText = responseText;
    _this4.responseJson = responseJson;
    _this4.name = "BytescaleGenericError";
    return _this4;
  }
  _inherits(BytescaleGenericError, _Error2);
  return runtime_createClass(BytescaleGenericError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Thrown when the Bytescale API returns a JSON error response.
 */
var BytescaleApiError = /*#__PURE__*/function (_Error3) {
  function BytescaleApiError(response) {
    var _this5;
    runtime_classCallCheck(this, BytescaleApiError);
    _this5 = _callSuper(this, BytescaleApiError, [response.error.message]);
    _this5.name = "BytescaleApiError";
    _this5.errorCode = response.error.code;
    _this5.details = response.error.details;
    return _this5;
  }
  _inherits(BytescaleApiError, _Error3);
  return runtime_createClass(BytescaleApiError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
function moveElementToEnd(array, element) {
  return [].concat(_toConsumableArray(array.filter(function (x) {
    return x !== element;
  })), _toConsumableArray(array.filter(function (x) {
    return x === element;
  })));
}
function querystring(params) {
  // The 'artifact' param must be the last param for certain transformations, such as async HLS jobs. For example,
  // given an artifact '!f=hls-h264&artifact=/video.m3u8' that returns a master M3U8 playlist containing relative
  // links to child M3U8 playlists (e.g. 'child1.m3u8'), when the child URLs inside the master M3U8 file are resolved
  // by the browser, the 'child1.m3u8' path essentially replaces everything after the '/' on the master M3U8 URL.
  // Thus, if query params existed after the 'artifact' param, they would be wiped out, causing the child M3U8
  // playlist to suddenly reference a different transformation.
  var keysReordered = moveElementToEnd(Object.keys(params), "artifact");
  return keysReordered.map(function (key) {
    return querystringSingleKey(key, params[key]);
  }).filter(function (part) {
    return part.length > 0;
  }).join("&");
}
function querystringSingleKey(key, value) {
  if (value instanceof Object) {
    // Matches 'array' or 'object' (which we want).
    return querystring(value);
  }
  return encodeBytescaleQuerystringKVP(key, String(value));
}
/**
 * Handles artifacts specially as these must use "/" instead of "%2F" in order for relative paths within the artifact's
 * contents to work (assumes user has replaced "?" with "!"). For example, M3U8 artifacts that contain relative URLs to
 * other M3U8s and/or media segments will only work if the user replaces "?" with "!" in the URL _and_ the artifact
 * query param value has been written using "/" instead of "%2F", as this then means the URLs become relative to the
 * artifact, as opposed to the file path.
 */
function encodeBytescaleQuerystringKVP(key, value) {
  if (key === "a" || key === "artifact") {
    return "".concat(key, "=").concat(encodeURIComponent(value).replace(/%2F/g, "/"));
  }
  return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
}
var JSONApiResponse = /*#__PURE__*/function () {
  function JSONApiResponse(raw) {
    runtime_classCallCheck(this, JSONApiResponse);
    this.raw = raw;
  }
  return runtime_createClass(JSONApiResponse, [{
    key: "value",
    value: function value() {
      try {
        var _this6 = this;
        return runtime_await(_this6.raw.json());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}();
var VoidApiResponse = /*#__PURE__*/function () {
  function VoidApiResponse(raw) {
    runtime_classCallCheck(this, VoidApiResponse);
    this.raw = raw;
  }
  return runtime_createClass(VoidApiResponse, [{
    key: "value",
    value: function value() {
      return runtime_await(undefined);
    }
  }]);
}();
var BinaryResult = /*#__PURE__*/function () {
  function BinaryResult(raw) {
    runtime_classCallCheck(this, BinaryResult);
    this.raw = raw;
  }
  return runtime_createClass(BinaryResult, [{
    key: "stream",
    value: function stream() {
      if (this.raw.bodyUsed) {
        throw new Error("Response body has already been consumed.");
      }
      if (this.raw.body === null) {
        throw new Error("Response body does not exist.");
      }
      return this.raw.body;
    }
  }, {
    key: "text",
    value: function text() {
      try {
        var _this7 = this;
        return runtime_await(_this7.raw.text());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "blob",
    value: function blob() {
      try {
        var _this8 = this;
        return runtime_await(_this8.raw.blob());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "json",
    value: function json() {
      try {
        var _this9 = this;
        return runtime_await(_this9.raw.json());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}();
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/CacheApi.ts
function CacheApi_typeof(o) { "@babel/helpers - typeof"; return CacheApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, CacheApi_typeof(o); }
function CacheApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function CacheApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function CacheApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, CacheApi_toPropertyKey(descriptor.key), descriptor); } }
function CacheApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) CacheApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) CacheApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function CacheApi_toPropertyKey(t) { var i = CacheApi_toPrimitive(t, "string"); return "symbol" == CacheApi_typeof(i) ? i : i + ""; }
function CacheApi_toPrimitive(t, r) { if ("object" != CacheApi_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != CacheApi_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function CacheApi_callSuper(t, o, e) { return o = CacheApi_getPrototypeOf(o), CacheApi_possibleConstructorReturn(t, CacheApi_isNativeReflectConstruct() ? Reflect.construct(o, e || [], CacheApi_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function CacheApi_possibleConstructorReturn(self, call) { if (call && (CacheApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return CacheApi_assertThisInitialized(self); }
function CacheApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function CacheApi_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (CacheApi_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function CacheApi_getPrototypeOf(o) { CacheApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return CacheApi_getPrototypeOf(o); }
function CacheApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) CacheApi_setPrototypeOf(subClass, superClass); }
function CacheApi_setPrototypeOf(o, p) { CacheApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return CacheApi_setPrototypeOf(o, p); }
/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var CacheApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  function CacheApi() {
    CacheApi_classCallCheck(this, CacheApi);
    return CacheApi_callSuper(this, CacheApi, arguments);
  }
  CacheApi_inherits(CacheApi, _runtime$BaseAPI);
  return CacheApi_createClass(CacheApi, [{
    key: "resetCache",
    value:
    /**
     * Resets the Bytescale CDN cache for a specific path, path prefix, or for your entire account.  You can choose to reset the edge cache, or permanent cache, or both caches.  *Warning:* Resetting the permanent cache (by setting ```resetPermanentCache: true```) may lead to a significant increase in processing time if numerous file transformations need to be re-performed upon their next request.  *Recommended:* Prevent cache resets by adding a ```?v=<etag>``` querystring parameter to your URLs. This ensures your URLs change when your files change, eliminating the need for cache resets. The `etag` field is returned by GetFileDetails and all upload operations, and can be saved to your database.  *Example patterns:*  - ```\"/_*\"``` - ```\"/raw/example.jpg\"``` - ```\"/image/example.jpg\"``` - ```\"/image/customers/abc/_*\"```  You may only use ```*``` at the end of the pattern. You must not include your account ID prefix in the pattern.
     */
    function resetCache(params) {
      try {
        var _this = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return CacheApi_await(_this.request({
          path: "/v2/accounts/{accountId}/cache/reset".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.resetCacheRequest
        }, undefined, [][0]), function (response) {
          return CacheApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}(BaseAPI);
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/FileApi.ts
function FileApi_typeof(o) { "@babel/helpers - typeof"; return FileApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, FileApi_typeof(o); }
function FileApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function FileApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function FileApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, FileApi_toPropertyKey(descriptor.key), descriptor); } }
function FileApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) FileApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) FileApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function FileApi_toPropertyKey(t) { var i = FileApi_toPrimitive(t, "string"); return "symbol" == FileApi_typeof(i) ? i : i + ""; }
function FileApi_toPrimitive(t, r) { if ("object" != FileApi_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != FileApi_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function FileApi_callSuper(t, o, e) { return o = FileApi_getPrototypeOf(o), FileApi_possibleConstructorReturn(t, FileApi_isNativeReflectConstruct() ? Reflect.construct(o, e || [], FileApi_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function FileApi_possibleConstructorReturn(self, call) { if (call && (FileApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FileApi_assertThisInitialized(self); }
function FileApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function FileApi_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (FileApi_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function FileApi_getPrototypeOf(o) { FileApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FileApi_getPrototypeOf(o); }
function FileApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FileApi_setPrototypeOf(subClass, superClass); }
function FileApi_setPrototypeOf(o, p) { FileApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FileApi_setPrototypeOf(o, p); }
/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var FileApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  function FileApi() {
    FileApi_classCallCheck(this, FileApi);
    return FileApi_callSuper(this, FileApi, arguments);
  }
  FileApi_inherits(FileApi, _runtime$BaseAPI);
  return FileApi_createClass(FileApi, [{
    key: "copyFile",
    value:
    /**
     * Copies a file synchronously.
     */
    function copyFile(params) {
      try {
        var _this = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FileApi_await(_this.request({
          path: "/v2/accounts/{accountId}/files/copy".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.copyFileRequest
        }, undefined, [][0]), function (response) {
          return FileApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Copies multiple files asynchronously.
     */
  }, {
    key: "copyFileBatch",
    value: function copyFileBatch(params) {
      try {
        var _this2 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FileApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/files/copy/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this2.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.copyFileBatchRequest
        }, undefined, [][0]), function (response) {
          return FileApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes a file synchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "deleteFile",
    value: function deleteFile(params) {
      try {
        var _this3 = this;
        var query = {};
        if (params.filePath !== undefined) {
          query["filePath"] = params.filePath;
        }
        var headers = {};
        return FileApi_await(_this3.request({
          path: "/v2/accounts/{accountId}/files".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this3.encodeParam("accountId", params.accountId)),
          method: "DELETE",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return FileApi_await(new VoidApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes multiple files asynchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "deleteFileBatch",
    value: function deleteFileBatch(params) {
      try {
        var _this4 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FileApi_await(_this4.request({
          path: "/v2/accounts/{accountId}/files/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this4.encodeParam("accountId", params.accountId)),
          method: "DELETE",
          headers: headers,
          query: query,
          body: params.deleteFileBatchRequest
        }, undefined, [][0]), function (response) {
          return FileApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Downloads a file in its original/unprocessed state.
     */
  }, {
    key: "downloadFile",
    value: function downloadFile(params) {
      try {
        var _this5 = this;
        var query = {};
        if (params.cache !== undefined) {
          query["cache"] = params.cache;
        }
        if (params.cacheTtl !== undefined) {
          query["cache_ttl"] = params.cacheTtl;
        }
        if (params.cacheTtl404 !== undefined) {
          query["cache_ttl_404"] = params.cacheTtl404;
        }
        if (params.version !== undefined) {
          query["version"] = params.version;
        }
        var headers = {};
        return FileApi_await(_this5.request({
          path: "/{accountId}/raw{filePath}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this5.encodeParam("accountId", params.accountId)).replace("{".concat("filePath", "}"),
          // @ts-ignore
          _this5.encodeParam("filePath", params.filePath)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, ["https://upcdn.io"][0]), function (response) {
          return new BinaryResult(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     */
  }, {
    key: "getFileDetails",
    value: function getFileDetails(params) {
      try {
        var _this6 = this;
        var query = {};
        if (params.filePath !== undefined) {
          query["filePath"] = params.filePath;
        }
        var headers = {};
        return FileApi_await(_this6.request({
          path: "/v2/accounts/{accountId}/files/details".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this6.encodeParam("accountId", params.accountId)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return FileApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Processes a file and returns the result.
     */
  }, {
    key: "processFile",
    value: function processFile(params) {
      try {
        var _this7 = this;
        var query = {};
        if (params.artifact !== undefined) {
          query["artifact"] = params.artifact;
        }
        if (params.cache !== undefined) {
          query["cache"] = params.cache;
        }
        if (params.cacheOnly !== undefined) {
          query["cache_only"] = params.cacheOnly;
        }
        if (params.cachePerm !== undefined) {
          query["cache_perm"] = params.cachePerm;
        }
        if (params.cacheTtl !== undefined) {
          query["cache_ttl"] = params.cacheTtl;
        }
        if (params.cacheTtl404 !== undefined) {
          query["cache_ttl_404"] = params.cacheTtl404;
        }
        if (params.transformationParams !== undefined) {
          query["transformationParams"] = params.transformationParams;
        }
        if (params.version !== undefined) {
          query["version"] = params.version;
        }
        var headers = {};
        return FileApi_await(_this7.request({
          path: "/{accountId}/{transformation}{filePath}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this7.encodeParam("accountId", params.accountId)).replace("{".concat("filePath", "}"),
          // @ts-ignore
          _this7.encodeParam("filePath", params.filePath)).replace("{".concat("transformation", "}"),
          // @ts-ignore
          _this7.encodeParam("transformation", params.transformation)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, ["https://upcdn.io"][0]), function (response) {
          return new BinaryResult(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Processes a file and saves the result.
     */
  }, {
    key: "processFileAndSave",
    value: function processFileAndSave(params) {
      try {
        var _this8 = this;
        var query = {};
        if (params.transformationParams !== undefined) {
          query["transformationParams"] = params.transformationParams;
        }
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FileApi_await(_this8.request({
          path: "/{accountId}/save/{transformation}{filePath}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this8.encodeParam("accountId", params.accountId)).replace("{".concat("filePath", "}"),
          // @ts-ignore
          _this8.encodeParam("filePath", params.filePath)).replace("{".concat("transformation", "}"),
          // @ts-ignore
          _this8.encodeParam("transformation", params.transformation)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.processFileAndSaveRequest
        }, undefined, ["https://upcdn.io"][0]), function (response) {
          return FileApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}(BaseAPI);
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/FolderApi.ts
function FolderApi_typeof(o) { "@babel/helpers - typeof"; return FolderApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, FolderApi_typeof(o); }
function FolderApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function FolderApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function FolderApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, FolderApi_toPropertyKey(descriptor.key), descriptor); } }
function FolderApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) FolderApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) FolderApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function FolderApi_toPropertyKey(t) { var i = FolderApi_toPrimitive(t, "string"); return "symbol" == FolderApi_typeof(i) ? i : i + ""; }
function FolderApi_toPrimitive(t, r) { if ("object" != FolderApi_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != FolderApi_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function FolderApi_callSuper(t, o, e) { return o = FolderApi_getPrototypeOf(o), FolderApi_possibleConstructorReturn(t, FolderApi_isNativeReflectConstruct() ? Reflect.construct(o, e || [], FolderApi_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function FolderApi_possibleConstructorReturn(self, call) { if (call && (FolderApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FolderApi_assertThisInitialized(self); }
function FolderApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function FolderApi_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (FolderApi_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function FolderApi_getPrototypeOf(o) { FolderApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FolderApi_getPrototypeOf(o); }
function FolderApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FolderApi_setPrototypeOf(subClass, superClass); }
function FolderApi_setPrototypeOf(o, p) { FolderApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FolderApi_setPrototypeOf(o, p); }
/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var FolderApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  function FolderApi() {
    FolderApi_classCallCheck(this, FolderApi);
    return FolderApi_callSuper(this, FolderApi, arguments);
  }
  FolderApi_inherits(FolderApi, _runtime$BaseAPI);
  return FolderApi_createClass(FolderApi, [{
    key: "copyFolder",
    value:
    /**
     * Copies a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     */
    function copyFolder(params) {
      try {
        var _this = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FolderApi_await(_this.request({
          path: "/v2/accounts/{accountId}/folders/copy".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.copyFolderRequest
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Copies multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     */
  }, {
    key: "copyFolderBatch",
    value: function copyFolderBatch(params) {
      try {
        var _this2 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FolderApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/folders/copy/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this2.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.copyFolderBatchRequest
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *External storage:* external files are only deleted when you directly delete a file or subfolder of a folder that has external storage configured. If you delete the folder itself, only the mapping is removed.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "deleteFolder",
    value: function deleteFolder(params) {
      try {
        var _this3 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FolderApi_await(_this3.request({
          path: "/v2/accounts/{accountId}/folders".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this3.encodeParam("accountId", params.accountId)),
          method: "DELETE",
          headers: headers,
          query: query,
          body: params.deleteFolderRequest
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *External storage:* external files are only deleted when you directly delete a file or subfolder of a folder that has external storage configured. If you delete the folder itself, only the mapping is removed.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "deleteFolderBatch",
    value: function deleteFolderBatch(params) {
      try {
        var _this4 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FolderApi_await(_this4.request({
          path: "/v2/accounts/{accountId}/folders/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this4.encodeParam("accountId", params.accountId)),
          method: "DELETE",
          headers: headers,
          query: query,
          body: params.deleteFolderBatchRequest
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets the full details (e.g. permission, storage layer, etc.) for a folder.  Returns an empty object if no settings have been configured for this folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "getFolderDetails",
    value: function getFolderDetails(params) {
      try {
        var _this5 = this;
        var query = {};
        if (params.folderPath !== undefined) {
          query["folderPath"] = params.folderPath;
        }
        var headers = {};
        return FolderApi_await(_this5.request({
          path: "/v2/accounts/{accountId}/folders".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this5.encodeParam("accountId", params.accountId)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the folder\'s contents.  The result may be paginated: subsequent pages can be requested by passing the ```cursor``` from the response into the next request.  Pagination is complete when the response includes `isPaginationComplete=true`.
     */
  }, {
    key: "listFolder",
    value: function listFolder(params) {
      try {
        var _this6 = this;
        var query = {};
        if (params.cursor !== undefined) {
          query["cursor"] = params.cursor;
        }
        if (params.dryRun !== undefined) {
          query["dryRun"] = params.dryRun;
        }
        if (params.folderPath !== undefined) {
          query["folderPath"] = params.folderPath;
        }
        if (params.includeFiles !== undefined) {
          query["includeFiles"] = params.includeFiles;
        }
        if (params.includeOverriddenStorage !== undefined) {
          query["includeOverriddenStorage"] = params.includeOverriddenStorage;
        }
        if (params.includePhysicalFolders !== undefined) {
          query["includePhysicalFolders"] = params.includePhysicalFolders;
        }
        if (params.includeVirtualFolders !== undefined) {
          query["includeVirtualFolders"] = params.includeVirtualFolders;
        }
        if (params.limit !== undefined) {
          query["limit"] = params.limit;
        }
        if (params.recursive !== undefined) {
          query["recursive"] = params.recursive;
        }
        var headers = {};
        return FolderApi_await(_this6.request({
          path: "/v2/accounts/{accountId}/folders/list".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this6.encodeParam("accountId", params.accountId)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Creates or updates the folder specified by the `folderPath`.  If the folder\'s ancestors do not exist, they will be created automatically (with empty FolderSettings).  Note: you don\'t need to create folders before uploading files to them.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "putFolder",
    value: function putFolder(params) {
      try {
        var _this7 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FolderApi_await(_this7.request({
          path: "/v2/accounts/{accountId}/folders".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this7.encodeParam("accountId", params.accountId)),
          method: "PUT",
          headers: headers,
          query: query,
          body: params.putFolderRequest
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}(BaseAPI);
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/JobApi.ts
function JobApi_typeof(o) { "@babel/helpers - typeof"; return JobApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, JobApi_typeof(o); }
function JobApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function JobApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function JobApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, JobApi_toPropertyKey(descriptor.key), descriptor); } }
function JobApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) JobApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) JobApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function JobApi_toPropertyKey(t) { var i = JobApi_toPrimitive(t, "string"); return "symbol" == JobApi_typeof(i) ? i : i + ""; }
function JobApi_toPrimitive(t, r) { if ("object" != JobApi_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != JobApi_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function JobApi_callSuper(t, o, e) { return o = JobApi_getPrototypeOf(o), JobApi_possibleConstructorReturn(t, JobApi_isNativeReflectConstruct() ? Reflect.construct(o, e || [], JobApi_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function JobApi_possibleConstructorReturn(self, call) { if (call && (JobApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return JobApi_assertThisInitialized(self); }
function JobApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function JobApi_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (JobApi_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function JobApi_getPrototypeOf(o) { JobApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return JobApi_getPrototypeOf(o); }
function JobApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) JobApi_setPrototypeOf(subClass, superClass); }
function JobApi_setPrototypeOf(o, p) { JobApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return JobApi_setPrototypeOf(o, p); }
/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var JobApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  function JobApi() {
    JobApi_classCallCheck(this, JobApi);
    return JobApi_callSuper(this, JobApi, arguments);
  }
  JobApi_inherits(JobApi, _runtime$BaseAPI);
  return JobApi_createClass(JobApi, [{
    key: "cancelJob",
    value:
    /**
     * Cancels an in-progress background job.  Requires a `secret_*` API key.
     */
    function cancelJob(params) {
      try {
        var _this = this;
        var query = {};
        var headers = {};
        return JobApi_await(_this.request({
          path: "/v2/accounts/{accountId}/jobs/{jobType}/{jobId}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this.encodeParam("accountId", params.accountId)).replace("{".concat("jobId", "}"),
          // @ts-ignore
          _this.encodeParam("jobId", params.jobId)).replace("{".concat("jobType", "}"),
          // @ts-ignore
          _this.encodeParam("jobType", params.jobType)),
          method: "DELETE",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return JobApi_await(new VoidApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets information on a background job.  Requires a `secret_*` API key.
     */
  }, {
    key: "getJob",
    value: function getJob(params) {
      try {
        var _this2 = this;
        var query = {};
        var headers = {};
        return JobApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/jobs/{jobType}/{jobId}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this2.encodeParam("accountId", params.accountId)).replace("{".concat("jobId", "}"),
          // @ts-ignore
          _this2.encodeParam("jobId", params.jobId)).replace("{".concat("jobType", "}"),
          // @ts-ignore
          _this2.encodeParam("jobType", params.jobType)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return JobApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the 10 most recently created jobs for the specified job type(s).  Requires a `secret_*` API key.
     */
  }, {
    key: "listRecentJobs",
    value: function listRecentJobs(params) {
      try {
        var _this3 = this;
        var query = {};
        if (params.jobType) {
          query["jobType"] = params.jobType;
        }
        var headers = {};
        return JobApi_await(_this3.request({
          path: "/v2/accounts/{accountId}/jobs".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this3.encodeParam("accountId", params.accountId)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return JobApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}(BaseAPI);
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/UploadApi.ts
function UploadApi_typeof(o) { "@babel/helpers - typeof"; return UploadApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, UploadApi_typeof(o); }
function UploadApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function UploadApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UploadApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UploadApi_toPropertyKey(descriptor.key), descriptor); } }
function UploadApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) UploadApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) UploadApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UploadApi_toPropertyKey(t) { var i = UploadApi_toPrimitive(t, "string"); return "symbol" == UploadApi_typeof(i) ? i : i + ""; }
function UploadApi_toPrimitive(t, r) { if ("object" != UploadApi_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != UploadApi_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function UploadApi_callSuper(t, o, e) { return o = UploadApi_getPrototypeOf(o), UploadApi_possibleConstructorReturn(t, UploadApi_isNativeReflectConstruct() ? Reflect.construct(o, e || [], UploadApi_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function UploadApi_possibleConstructorReturn(self, call) { if (call && (UploadApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return UploadApi_assertThisInitialized(self); }
function UploadApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function UploadApi_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (UploadApi_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function UploadApi_getPrototypeOf(o) { UploadApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return UploadApi_getPrototypeOf(o); }
function UploadApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) UploadApi_setPrototypeOf(subClass, superClass); }
function UploadApi_setPrototypeOf(o, p) { UploadApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return UploadApi_setPrototypeOf(o, p); }
/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var UploadApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  function UploadApi() {
    UploadApi_classCallCheck(this, UploadApi);
    return UploadApi_callSuper(this, UploadApi, arguments);
  }
  UploadApi_inherits(UploadApi, _runtime$BaseAPI);
  return UploadApi_createClass(UploadApi, [{
    key: "beginMultipartUpload",
    value:
    /**
     * Begins a new multipart file upload process.
     */
    function beginMultipartUpload(params) {
      try {
        var _this = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return UploadApi_await(_this.request({
          path: "/v2/accounts/{accountId}/uploads".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.beginMultipartUploadRequest
        }, undefined, [][0]), function (response) {
          return UploadApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Marks an upload part as uploaded.  You must call this endpoint after you have successfully issued a `PUT` request to the `uploadUrl` on the corresponding UploadPart.
     */
  }, {
    key: "completeUploadPart",
    value: function completeUploadPart(params) {
      try {
        var _this2 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return UploadApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/uploads/{uploadId}/parts/{uploadPartIndex}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this2.encodeParam("accountId", params.accountId)).replace("{".concat("uploadId", "}"),
          // @ts-ignore
          _this2.encodeParam("uploadId", params.uploadId)).replace("{".concat("uploadPartIndex", "}"),
          // @ts-ignore
          _this2.encodeParam("uploadPartIndex", params.uploadPartIndex)),
          method: "PUT",
          headers: headers,
          query: query,
          body: params.completeUploadPartRequest
        }, undefined, [][0]), function (response) {
          return UploadApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets a remaining upload part for a multipart file upload.
     */
  }, {
    key: "getUploadPart",
    value: function getUploadPart(params) {
      try {
        var _this3 = this;
        var query = {};
        var headers = {};
        return UploadApi_await(_this3.request({
          path: "/v2/accounts/{accountId}/uploads/{uploadId}/parts/{uploadPartIndex}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this3.encodeParam("accountId", params.accountId)).replace("{".concat("uploadId", "}"),
          // @ts-ignore
          _this3.encodeParam("uploadId", params.uploadId)).replace("{".concat("uploadPartIndex", "}"),
          // @ts-ignore
          _this3.encodeParam("uploadPartIndex", params.uploadPartIndex)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return UploadApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the remaining upload parts for a multipart file upload.  An empty array is returned when the upload is complete.
     */
  }, {
    key: "listUploadParts",
    value: function listUploadParts(params) {
      try {
        var _this4 = this;
        var query = {};
        var headers = {};
        return UploadApi_await(_this4.request({
          path: "/v2/accounts/{accountId}/uploads/{uploadId}/parts".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this4.encodeParam("accountId", params.accountId)).replace("{".concat("uploadId", "}"),
          // @ts-ignore
          _this4.encodeParam("uploadId", params.uploadId)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return UploadApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Upload from a URL with a single HTTP request:
     */
  }, {
    key: "uploadFromUrl",
    value: function uploadFromUrl(params) {
      try {
        var _this5 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return UploadApi_await(_this5.request({
          path: "/v2/accounts/{accountId}/uploads/url".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this5.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.uploadFromUrlRequest
        }, undefined, [][0]), function (response) {
          return UploadApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}(BaseAPI);
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/index.ts
/* tslint:disable */
/* eslint-disable */





;// CONCATENATED MODULE: ./src/public/shared/generated/index.ts
/* tslint:disable */
/* eslint-disable */



;// CONCATENATED MODULE: ./src/public/shared/CommonTypes.ts
/**
 * Workaround for tsc aliases, where we cannot export implementation-less libs in our dists.
 */
var CommonTypesNoOp = false;
;// CONCATENATED MODULE: ./src/private/TypeUtils.ts
function assertUnreachable(x) {
  throw new Error("Didn't expect to get here: ".concat(JSON.stringify(x)));
}
function isDefinedEntry(object) {
  return object[1] !== undefined && object[1] !== null;
}
;// CONCATENATED MODULE: ./src/public/shared/UrlBuilder.ts
function UrlBuilder_typeof(o) { "@babel/helpers - typeof"; return UrlBuilder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, UrlBuilder_typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || UrlBuilder_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function UrlBuilder_toConsumableArray(arr) { return UrlBuilder_arrayWithoutHoles(arr) || UrlBuilder_iterableToArray(arr) || UrlBuilder_unsupportedIterableToArray(arr) || UrlBuilder_nonIterableSpread(); }
function UrlBuilder_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function UrlBuilder_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return UrlBuilder_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return UrlBuilder_arrayLikeToArray(o, minLen); }
function UrlBuilder_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function UrlBuilder_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return UrlBuilder_arrayLikeToArray(arr); }
function UrlBuilder_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function UrlBuilder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UrlBuilder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UrlBuilder_toPropertyKey(descriptor.key), descriptor); } }
function UrlBuilder_createClass(Constructor, protoProps, staticProps) { if (protoProps) UrlBuilder_defineProperties(Constructor.prototype, protoProps); if (staticProps) UrlBuilder_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UrlBuilder_toPropertyKey(t) { var i = UrlBuilder_toPrimitive(t, "string"); return "symbol" == UrlBuilder_typeof(i) ? i : i + ""; }
function UrlBuilder_toPrimitive(t, r) { if ("object" != UrlBuilder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != UrlBuilder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var UrlBuilder = /*#__PURE__*/function () {
  function UrlBuilder() {
    UrlBuilder_classCallCheck(this, UrlBuilder);
  }
  return UrlBuilder_createClass(UrlBuilder, null, [{
    key: "url",
    value:
    /**
     * Builds a URL to either a raw file or a transformed file.
     *
     * Example 1) Getting a publicly-accessible raw file URL:
     *
     *   new UrlBuilder().url({ accountId: "1234abc", filePath: "/example.jpg" })
     *
     * Example 2) Getting a publicly-accessible image URL, resized to 500x500:
     *
     *   new UrlBuilder().url({ accountId: "1234abc", filePath: "/example.jpg", options: { transformation: { type: "image", params: { w: 500, h: 500, fit: "crop" } } } })
     *
     * Example 3) Getting a privately-accessible image URL, resized to 500x500 (requires 'AuthManager.beginAuthSession' to be called before accessing the URL):
     *
     *   new UrlBuilder().url({ accountId: "1234abc", filePath: "/example.jpg", options: { transformation: { type: "image", params: { w: 500, h: 500, fit: "crop" } }, auth: true } })
     *
     * Example 4) Getting a publicly-accessible image URL, resized using a transformation preset called "thumbnail" that was created manually in the Bytescale Dashboard:
     *
     *   new UrlBuilder().url({ accountId: "1234abc", filePath: "/example.jpg", options: { transformation: { type: "preset", preset: "thumbnail" } } })
     */
    function url(params) {
      var _a;
      return ((_a = params.options) === null || _a === void 0 ? void 0 : _a.transformation) === undefined ? this.raw(params) : this.transformation(params, params.options);
    }
  }, {
    key: "raw",
    value: function raw(params) {
      var _a;
      var baseUrl = this.getBaseUrl(params, "raw");
      var commonParams = this.getCommonQueryParams((_a = params.options) !== null && _a !== void 0 ? _a : {});
      return this.addQueryParams(baseUrl, commonParams);
    }
  }, {
    key: "transformation",
    value: function transformation(params, trans) {
      var _a;
      var baseUrl = this.getBaseUrl(params, trans.transformation === "preset" ? trans.transformationPreset : trans.transformation);
      var transParams = trans.transformation === "preset" ? [] : this.getTransformationParams(trans);
      var commonParams = this.getCommonQueryParams((_a = params.options) !== null && _a !== void 0 ? _a : {});
      var transCommonParams = this.getCommonTransformationQueryParams(trans);
      // This format puts "artifact" at the end, which isn't required, but is convention.
      return this.addQueryParams(baseUrl, [].concat(UrlBuilder_toConsumableArray(transParams), UrlBuilder_toConsumableArray(commonParams), UrlBuilder_toConsumableArray(transCommonParams)));
    }
  }, {
    key: "getBaseUrl",
    value: function getBaseUrl(params, prefix) {
      var _a, _b;
      var cdnUrl = (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.cdnUrl) !== null && _b !== void 0 ? _b : BytescaleApiClientConfigUtils.defaultCdnUrl;
      var filePathEncoded = encodeURIComponent(params.filePath).replace(/%2F/g, "/");
      return "".concat(cdnUrl, "/").concat(params.accountId, "/").concat(prefix).concat(filePathEncoded);
    }
  }, {
    key: "getCommonTransformationQueryParams",
    value: function getCommonTransformationQueryParams(trans) {
      return this.makeQueryParams({
        cacheOnly: null,
        cachePermanently: null,
        // Keep this as the last param: this is required for certain transformations, such as async HLS jobs. For example,
        // given an artifact '!f=hls-h264&artifact=/video.m3u8' that returns a master M3U8 playlist containing relative
        // links to child M3U8 playlists (e.g. 'child1.m3u8'), when the child URLs inside the master M3U8 file are resolved
        // by the browser, the 'child1.m3u8' path essentially replaces everything after the '/' on the master M3U8 URL.
        // Thus, if query params existed after the 'artifact' param, they would be wiped out, causing the child M3U8
        // playlist to suddenly reference a different transformation.
        artifact: null
      }, {
        cacheOnly: "cache_only",
        cachePermanently: "cache_perm"
      })(trans);
    }
  }, {
    key: "getCommonQueryParams",
    value: function getCommonQueryParams(params) {
      return this.makeQueryParams({
        cache: null,
        cacheTtl: null,
        cacheTtl404: null,
        version: null,
        forceDownloadPrompt: null
      }, {
        cacheTtl: "cache_ttl",
        cacheTtl404: "cache_ttl_404",
        forceDownloadPrompt: "download"
      })(params);
    }
    /**
     * Masks the querystring params per the 'keys' array.
     *
     * Order sensitive: querystring params will appear per the order of the 'keys' array.
     */
  }, {
    key: "makeQueryParams",
    value: function makeQueryParams(keyPrototype, keyOverrides) {
      return function (data) {
        var result = [];
        var keys = Object.keys(keyPrototype);
        keys.forEach(function (key) {
          var _a;
          var value = data[key];
          if (value !== undefined) {
            result.push([(_a = keyOverrides[key]) !== null && _a !== void 0 ? _a : key, value.toString()]);
          }
        });
        return result;
      };
    }
  }, {
    key: "getTransformationParams",
    value: function getTransformationParams(trans) {
      var params = trans.transformationParams;
      if (params === undefined) {
        return [];
      }
      var serializeObj = function serializeObj(obj) {
        return Object.entries(obj).filter(isDefinedEntry).map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];
          return [key, value.toString()];
        });
      };
      return Array.isArray(params) ? params.flatMap(serializeObj) : serializeObj(params);
    }
  }, {
    key: "addQueryParams",
    value: function addQueryParams(baseUrl, params) {
      if (params.length === 0) {
        return baseUrl;
      }
      return "".concat(baseUrl, "?").concat(params.map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          value = _ref4[1];
        return encodeBytescaleQuerystringKVP(key, value);
      }).join("&"));
    }
  }]);
}();
;// CONCATENATED MODULE: ./src/public/shared/UrlBuilderTypes.ts
/**
 * Workaround for tsc aliases, where we cannot export implementation-less libs in our dists.
 */
var UrlBuilderTypesNoOp = false;
;// CONCATENATED MODULE: ./src/public/shared/index.ts




;// CONCATENATED MODULE: ./src/private/UploadManagerBase.ts
function UploadManagerBase_empty() {}
function UploadManagerBase_awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(UploadManagerBase_empty) : Promise.resolve();
  }
}
function UploadManagerBase_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function UploadManagerBase_rethrow(thrown, value) {
  if (thrown) throw value;
  return value;
}
function UploadManagerBase_finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }
  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }
  return finalizer(false, result);
}
function UploadManagerBase_continue(value, then) {
  return value && value.then ? value.then(then) : then(value);
}
function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
function _invokeIgnored(body) {
  var result = body();
  if (result && result.then) {
    return result.then(UploadManagerBase_empty);
  }
}
function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }
        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }
    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }
    pact.s = state;
    pact.v = value;
    var observer = pact.o;
    if (observer) {
      observer(pact);
    }
  }
}
var _Pact = /*#__PURE__*/function () {
  function _Pact() {}
  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;
    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;
      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }
        return result;
      } else {
        return this;
      }
    }
    this.o = function (_this) {
      try {
        var value = _this.v;
        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };
    return result;
  };
  return _Pact;
}();
function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}
function _for(test, update, body) {
  var stage;
  for (;;) {
    var shouldContinue = test();
    if (_isSettledPact(shouldContinue)) {
      shouldContinue = shouldContinue.v;
    }
    if (!shouldContinue) {
      return result;
    }
    if (shouldContinue.then) {
      stage = 0;
      break;
    }
    var result = body();
    if (result && result.then) {
      if (_isSettledPact(result)) {
        result = result.s;
      } else {
        stage = 1;
        break;
      }
    }
    if (update) {
      var updateValue = update();
      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
        stage = 2;
        break;
      }
    }
  }
  var pact = new _Pact();
  var reject = _settle.bind(null, pact, 2);
  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
  return pact;
  function _resumeAfterBody(value) {
    result = value;
    do {
      if (update) {
        updateValue = update();
        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
          updateValue.then(_resumeAfterUpdate).then(void 0, reject);
          return;
        }
      }
      shouldContinue = test();
      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {
        _settle(pact, 1, result);
        return;
      }
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        return;
      }
      result = body();
      if (_isSettledPact(result)) {
        result = result.v;
      }
    } while (!result || !result.then);
    result.then(_resumeAfterBody).then(void 0, reject);
  }
  function _resumeAfterTest(shouldContinue) {
    if (shouldContinue) {
      result = body();
      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
      } else {
        _resumeAfterBody(result);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
  function _resumeAfterUpdate() {
    if (shouldContinue = test()) {
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _resumeAfterTest(shouldContinue);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
}
function _continueIgnored(value) {
  if (value && value.then) {
    return value.then(UploadManagerBase_empty);
  }
}
function UploadManagerBase_typeof(o) { "@babel/helpers - typeof"; return UploadManagerBase_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, UploadManagerBase_typeof(o); }
function UploadManagerBase_toConsumableArray(arr) { return UploadManagerBase_arrayWithoutHoles(arr) || UploadManagerBase_iterableToArray(arr) || UploadManagerBase_unsupportedIterableToArray(arr) || UploadManagerBase_nonIterableSpread(); }
function UploadManagerBase_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function UploadManagerBase_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return UploadManagerBase_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return UploadManagerBase_arrayLikeToArray(o, minLen); }
function UploadManagerBase_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function UploadManagerBase_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return UploadManagerBase_arrayLikeToArray(arr); }
function UploadManagerBase_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function UploadManagerBase_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UploadManagerBase_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UploadManagerBase_toPropertyKey(descriptor.key), descriptor); } }
function UploadManagerBase_createClass(Constructor, protoProps, staticProps) { if (protoProps) UploadManagerBase_defineProperties(Constructor.prototype, protoProps); if (staticProps) UploadManagerBase_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UploadManagerBase_toPropertyKey(t) { var i = UploadManagerBase_toPrimitive(t, "string"); return "symbol" == UploadManagerBase_typeof(i) ? i : i + ""; }
function UploadManagerBase_toPrimitive(t, r) { if ("object" != UploadManagerBase_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != UploadManagerBase_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

/**
 * Methods common to UploadManagerNode and UploadManagerBrowser.
 */
var UploadManagerBase = /*#__PURE__*/function () {
  function UploadManagerBase(config) {
    UploadManagerBase_classCallCheck(this, UploadManagerBase);
    this.config = config;
    this.stringMimeType = "text/plain";
    this.defaultMaxConcurrentUploadParts = 4;
    this.intervalMs = 500;
    this.uploadApi = new UploadApi(config);
    this.accountId = BytescaleApiClientConfigUtils.getAccountId(config);
  }
  return UploadManagerBase_createClass(UploadManagerBase, [{
    key: "upload",
    value: function upload(request) {
      try {
        var _this = this;
        _this.assertNotCancelled(request);
        var source = _this.processUploadSource(request.data);
        var preUploadInfo = _this.getPreUploadInfo(request, source);
        var bytesTotal = preUploadInfo.size;
        var makeOnProgressForPart = _this.makeOnProgressForPartFactory(request, bytesTotal);
        var init = _this.preUpload(source);
        // Raise initial progress event SYNCHRONOUSLY.
        if (request.onProgress !== undefined) {
          request.onProgress(_this.makeProgressEvent(0, bytesTotal));
        }
        return UploadManagerBase_await(_this.beginUpload(request, preUploadInfo), function (uploadInfo) {
          var partCount = uploadInfo.uploadParts.count;
          var parts = UploadManagerBase_toConsumableArray(Array(partCount).keys());
          var _this$makeCancellatio = _this.makeCancellationMethods(),
            cancel = _this$makeCancellatio.cancel,
            addCancellationHandler = _this$makeCancellatio.addCancellationHandler;
          var intervalHandle = setInterval(_this.onIntervalTick(request, cancel), _this.intervalMs);
          var uploadedParts;
          return UploadManagerBase_continue(UploadManagerBase_finallyRethrows(function () {
            return UploadManagerBase_await(_this.mapAsync(parts, preUploadInfo.maxConcurrentUploadParts, _async(function (part) {
              return _this.uploadPart(request, source, part, uploadInfo, makeOnProgressForPart(), addCancellationHandler);
            })), function (_this$mapAsync) {
              uploadedParts = _this$mapAsync;
              return UploadManagerBase_awaitIgnored(_this.postUpload(init));
            });
          }, function (_wasThrown, _result) {
            clearInterval(intervalHandle);
            return UploadManagerBase_rethrow(_wasThrown, _result);
          }), function () {
            var etag = uploadedParts.flatMap(function (x) {
              return x.status === "Completed" ? [x.etag] : [];
            })[0];
            return Object.assign(Object.assign({}, uploadInfo.file), {
              etag: etag // The 'etag' in the original 'uploadInfo.file' will be null, so we set it to the final etag value here.
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getBlobInfo",
    value: function getBlobInfo(_ref) {
      var _ref$value = _ref.value,
        name = _ref$value.name,
        size = _ref$value.size,
        type = _ref$value.type;
      return {
        // Some browsers/OSs return 'type: ""' for files with unknown MIME types, like HEICs, which causes a validation
        // error from the Bytescale API as "" is not a valid MIME type, so we coalesce to undefined here.
        mime: type === "" ? undefined : type,
        size: size,
        originalFileName: name,
        maxConcurrentUploadParts: undefined
      };
    }
  }, {
    key: "onIntervalTick",
    value: function onIntervalTick(request, cancel) {
      var _this2 = this;
      return function () {
        if (_this2.isCancelled(request)) {
          cancel();
        }
      };
    }
  }, {
    key: "makeCancellationMethods",
    value: function makeCancellationMethods() {
      var cancellationHandlers = [];
      var addCancellationHandler = function addCancellationHandler(ca) {
        cancellationHandlers.push(ca);
      };
      var cancel = function cancel() {
        return cancellationHandlers.forEach(function (x) {
          return x();
        });
      };
      return {
        cancel: cancel,
        addCancellationHandler: addCancellationHandler
      };
    }
    /**
     * Returns a callback, which when called, returns a callback that can be used by ONE specific part to report its progress.
     */
  }, {
    key: "makeOnProgressForPartFactory",
    value: function makeOnProgressForPartFactory(request, bytesTotal) {
      var _this3 = this;
      var onProgress = request.onProgress;
      if (onProgress === undefined) {
        return function () {
          return function () {};
        };
      }
      var bytesSent = 0;
      return function () {
        var bytesSentForPart = 0;
        return function (bytesSentTotalForPart) {
          var delta = bytesSentTotalForPart - bytesSentForPart;
          bytesSentForPart += delta;
          bytesSent += delta;
          onProgress(_this3.makeProgressEvent(bytesSent, bytesTotal));
        };
      };
    }
  }, {
    key: "makeProgressEvent",
    value: function makeProgressEvent(bytesSent, bytesTotal) {
      return {
        bytesTotal: bytesTotal,
        bytesSent: bytesSent,
        progress: Math.round(bytesSent / bytesTotal * 100)
      };
    }
  }, {
    key: "assertNotCancelled",
    value: function assertNotCancelled(request) {
      if (this.isCancelled(request)) {
        throw new CancelledError();
      }
    }
  }, {
    key: "isCancelled",
    value: function isCancelled(request) {
      var _a;
      return ((_a = request.cancellationToken) === null || _a === void 0 ? void 0 : _a.isCancelled) === true;
    }
  }, {
    key: "beginUpload",
    value: function beginUpload(request, _ref2) {
      var size = _ref2.size,
        mime = _ref2.mime,
        originalFileName = _ref2.originalFileName;
      try {
        var _this4 = this;
        return UploadManagerBase_await(_this4.uploadApi.beginMultipartUpload({
          accountId: _this4.accountId,
          beginMultipartUploadRequest: {
            metadata: request.metadata,
            mime: mime,
            originalFileName: originalFileName,
            path: request.path,
            protocol: "1.1",
            size: size,
            tags: request.tags
          }
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "uploadPart",
    value: function uploadPart(request, source, partIndex, uploadInfo, onProgress, addCancellationHandler) {
      try {
        var _this5 = this;
        _this5.assertNotCancelled(request);
        return UploadManagerBase_await(_this5.getUploadPart(partIndex, uploadInfo), function (part) {
          _this5.assertNotCancelled(request);
          return UploadManagerBase_await(_this5.putUploadPart(part, source, onProgress, addCancellationHandler), function (etag) {
            _this5.assertNotCancelled(request);
            return UploadManagerBase_await(_this5.uploadApi.completeUploadPart({
              accountId: _this5.accountId,
              uploadId: uploadInfo.uploadId,
              uploadPartIndex: partIndex,
              completeUploadPartRequest: {
                etag: etag
              }
            }));
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Returns etag for the part.
     */
  }, {
    key: "putUploadPart",
    value: function putUploadPart(part, source, onProgress, addCancellationHandler) {
      try {
        var _this6 = this;
        var contentLength = part.range.inclusiveEnd + 1 - part.range.inclusiveStart;
        return UploadManagerBase_await(_this6.doPutUploadPart(part, contentLength, source, onProgress, addCancellationHandler), function (_ref3) {
          var status = _ref3.status,
            etag = _ref3.etag;
          if (Math.floor(status / 100) !== 2) {
            throw new Error("Failed to upload part (".concat(status, ")."));
          }
          if (etag === undefined) {
            throw new Error("No 'etag' response header found in upload part response.");
          }
          // Always send 100% for part, as some UploadManager implementations either don't report progress, or may not report the last chunk uploaded.
          onProgress(contentLength);
          return etag;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getUploadPart",
    value: function getUploadPart(partIndex, uploadInfo) {
      try {
        var _this7 = this;
        if (partIndex === 0) {
          return UploadManagerBase_await(uploadInfo.uploadParts.first);
        }
        return UploadManagerBase_await(_this7.uploadApi.getUploadPart({
          uploadId: uploadInfo.uploadId,
          accountId: _this7.accountId,
          uploadPartIndex: partIndex
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getPreUploadInfo",
    value: function getPreUploadInfo(request, source) {
      var _a, _b, _c;
      var partial = this.getPreUploadInfoPartial(request, source);
      return {
        maxConcurrentUploadParts: (_a = partial.maxConcurrentUploadParts) !== null && _a !== void 0 ? _a : this.defaultMaxConcurrentUploadParts,
        originalFileName: (_b = request.originalFileName) !== null && _b !== void 0 ? _b : partial.originalFileName,
        mime: (_c = request.mime) !== null && _c !== void 0 ? _c : partial.mime,
        size: partial.size
      };
    }
  }, {
    key: "mapAsync",
    value: function mapAsync(items, concurrency, callback) {
      try {
        var result = [];
        var workQueue = UploadManagerBase_toConsumableArray(items);
        return UploadManagerBase_await(Promise.all(UploadManagerBase_toConsumableArray(Array(concurrency).keys()).map(_async(function () {
          return _continueIgnored(_for(function () {
            return workQueue.length > 0;
          }, void 0, function () {
            var work = workQueue.shift(); // IMPORTANT: use 'shift' instead of 'pop' to ensure 'items' are processed in order when 'concurrency = 1'.
            return _invokeIgnored(function () {
              if (work !== undefined) {
                var _push = result.push;
                return UploadManagerBase_await(callback(work), function (_callback) {
                  _push.call(result, _callback);
                });
              }
            });
          }));
        }))), function () {
          return result;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}();
;// CONCATENATED MODULE: external "stream"
var x = function(y) {
	var x = {}; __lib_require__.d(x, y); return x
} 
var y = function(x) { return function() { return x; }; }
var external_stream_namespaceObject = x({ ["Readable"]: function() { return __WEBPACK_EXTERNAL_MODULE_stream__.Readable; } });
;// CONCATENATED MODULE: ./src/private/StreamUtils.ts
function StreamUtils_typeof(o) { "@babel/helpers - typeof"; return StreamUtils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, StreamUtils_typeof(o); }
function StreamUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function StreamUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, StreamUtils_toPropertyKey(descriptor.key), descriptor); } }
function StreamUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) StreamUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) StreamUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function StreamUtils_toPropertyKey(t) { var i = StreamUtils_toPrimitive(t, "string"); return "symbol" == StreamUtils_typeof(i) ? i : i + ""; }
function StreamUtils_toPrimitive(t, r) { if ("object" != StreamUtils_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != StreamUtils_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var StreamUtils = /*#__PURE__*/function () {
  function StreamUtils() {
    StreamUtils_classCallCheck(this, StreamUtils);
  }
  return StreamUtils_createClass(StreamUtils, null, [{
    key: "create",
    value: function create() {
      var readable = new external_stream_namespaceObject.Readable();
      readable._read = function () {}; // _read is required but you can noop it
      return readable;
    }
  }, {
    key: "empty",
    value: function empty() {
      var readable = StreamUtils.create();
      StreamUtils.endStream(readable);
      return readable;
    }
  }, {
    key: "fromArrayBuffer",
    value: function fromArrayBuffer(buffer) {
      return StreamUtils.fromBuffer(Buffer.from(buffer));
    }
  }, {
    key: "fromBuffer",
    value: function fromBuffer(buffer) {
      var readable = StreamUtils.create();
      readable.push(buffer);
      StreamUtils.endStream(readable);
      return readable;
    }
  }, {
    key: "endStream",
    value: function endStream(readable) {
      readable.push(null);
    }
  }]);
}();
;// CONCATENATED MODULE: ./src/private/NodeChunkedStream.ts
function NodeChunkedStream_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function NodeChunkedStream_typeof(o) { "@babel/helpers - typeof"; return NodeChunkedStream_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, NodeChunkedStream_typeof(o); }
function NodeChunkedStream_slicedToArray(arr, i) { return NodeChunkedStream_arrayWithHoles(arr) || NodeChunkedStream_iterableToArrayLimit(arr, i) || NodeChunkedStream_unsupportedIterableToArray(arr, i) || NodeChunkedStream_nonIterableRest(); }
function NodeChunkedStream_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function NodeChunkedStream_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return NodeChunkedStream_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return NodeChunkedStream_arrayLikeToArray(o, minLen); }
function NodeChunkedStream_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function NodeChunkedStream_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function NodeChunkedStream_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function NodeChunkedStream_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function NodeChunkedStream_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, NodeChunkedStream_toPropertyKey(descriptor.key), descriptor); } }
function NodeChunkedStream_createClass(Constructor, protoProps, staticProps) { if (protoProps) NodeChunkedStream_defineProperties(Constructor.prototype, protoProps); if (staticProps) NodeChunkedStream_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function NodeChunkedStream_toPropertyKey(t) { var i = NodeChunkedStream_toPrimitive(t, "string"); return "symbol" == NodeChunkedStream_typeof(i) ? i : i + ""; }
function NodeChunkedStream_toPrimitive(t, r) { if ("object" != NodeChunkedStream_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != NodeChunkedStream_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

/**
 * For Node.js streams only:
 *
 * Converts a stream into a stream of streams, where the next stream is requested via '.take(sizeInBytes: number): Stream'
 *
 * This allows the source stream to be sequentially read (in serial) as a sequence of sub-streams, for the purpose of
 * issuing PutObject requests for a multipart upload, whereby each request requires its own stream, but where that stream
 * needs to be a slice of the source stream.
 */
var NodeChunkedStream = /*#__PURE__*/function () {
  function NodeChunkedStream(source) {
    NodeChunkedStream_classCallCheck(this, NodeChunkedStream);
    this.source = source;
    this.buffer = Buffer.alloc(0);
    this.isSourceFullyConsumed = false; // true if the source stream indicates it has finished.
    this.isFinishedConsuming = false; // true if _we_ indicate we have finished reading all we want from the stream.
    this.resolver = undefined;
  }
  /**
   * If the source stream is larger than the 'size' the user is consuming (i.e. they're only wanting to upload a subset
   * of the stream) then the stream won't be resolved by the 'end' event inside 'runChunkPipeline', so calling this
   * method is necessary.
   */
  return NodeChunkedStream_createClass(NodeChunkedStream, [{
    key: "finishedConsuming",
    value: function finishedConsuming() {
      this.isFinishedConsuming = true;
      if (this.resolver !== undefined) {
        this.resolver();
      }
    }
    /**
     * Promise resolves when the entire stream has finished processing, or an error occurs.
     * You must call 'take' a sufficient number of times after calling this method in order for this promise to resolve.
     */
  }, {
    key: "runChunkPipeline",
    value: function runChunkPipeline() {
      try {
        var _this = this;
        return NodeChunkedStream_await(new Promise(function (resolve, reject) {
          _this.resolver = resolve;
          var onError = function onError(error) {
            removeListeners();
            reject(error);
          };
          var onEnd = function onEnd() {
            _this.isSourceFullyConsumed = true;
            removeListeners();
            resolve();
          };
          var onData = function onData(buffer) {
            try {
              if (_this.isFinishedConsuming) {
                return;
              }
              if (_this.consumer === undefined) {
                console.warn("Stream yielded data while paused. The data will be buffered, but excessive buffering can cause memory issues.");
                _this.buffer = Buffer.concat([_this.buffer, buffer]);
                return;
              }
              if (_this.consumer.bytesRemaining <= 0) {
                throw new Error("Consumer requires zero bytes, so should not be consuming from the stream.");
              }
              if (_this.buffer.byteLength > 0) {
                throw new Error("Buffer was expected to be empty (as it should have been flushed to the consumer when '.take' was called).");
              }
              var splitResult = _this.splitBuffer(buffer, _this.consumer.bytesRemaining);
              if (splitResult === undefined) {
                return; // Received empty data.
              }
              var _splitResult = NodeChunkedStream_slicedToArray(splitResult, 2),
                consumed = _splitResult[0],
                remaining = _splitResult[1];
              _this.buffer = remaining;
              _this.consumer.bytesRemaining -= consumed.byteLength;
              _this.consumer.stream.push(consumed);
              if (_this.consumer.bytesRemaining === 0) {
                StreamUtils.endStream(_this.consumer.stream);
                _this.consumer = undefined;
                _this.source.pause();
              }
            } catch (e) {
              removeListeners();
              reject(e);
            }
          };
          var removeListeners = function removeListeners() {
            _this.source.removeListener("data", onData);
            _this.source.removeListener("error", onError);
            _this.source.removeListener("end", onEnd);
          };
          _this.source.on("data", onData);
          _this.source.on("error", onError);
          _this.source.on("end", onEnd);
          _this.source.pause(); // Resumed when 'take' is called.
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Only call 'take' after the previously returned stream has been fully consumed.
     */
  }, {
    key: "take",
    value: function take(bytes) {
      var _a;
      if (this.consumer !== undefined) {
        throw new Error("The stream from the previous 'take' call must be fully consumed before calling 'take' again.");
      }
      if (bytes <= 0) {
        return StreamUtils.empty();
      }
      var readable = StreamUtils.create();
      var consumedFromBuffer = this.consumeFromBuffer(bytes);
      var consumedFromBufferLength = (_a = consumedFromBuffer === null || consumedFromBuffer === void 0 ? void 0 : consumedFromBuffer.length) !== null && _a !== void 0 ? _a : 0;
      var bytesToConsumeFromStream = bytes - consumedFromBufferLength;
      if (consumedFromBuffer !== undefined) {
        readable.push(consumedFromBuffer);
      }
      if (bytesToConsumeFromStream > 0) {
        if (this.isSourceFullyConsumed) {
          throw new Error("Stream finished processing earlier than expected. The \"size\" parameter is likely larger than the stream's actual contents.");
        }
        this.consumer = {
          bytesRemaining: bytesToConsumeFromStream,
          stream: readable
        };
        this.source.resume();
      } else {
        StreamUtils.endStream(readable);
      }
      return readable;
    }
  }, {
    key: "consumeFromBuffer",
    value: function consumeFromBuffer(bytes) {
      var splitResult = this.splitBuffer(this.buffer, bytes);
      if (splitResult === undefined) {
        return undefined;
      }
      var _splitResult2 = NodeChunkedStream_slicedToArray(splitResult, 2),
        consumed = _splitResult2[0],
        remaining = _splitResult2[1];
      this.buffer = remaining;
      return consumed;
    }
  }, {
    key: "splitBuffer",
    value: function splitBuffer(buffer, maxBytes) {
      if (buffer.byteLength === 0) {
        return undefined;
      }
      var bytesToConsume = Math.min(maxBytes, buffer.byteLength);
      if (bytesToConsume === buffer.byteLength) {
        return [buffer, Buffer.alloc(0)]; // Optimization
      }
      var consumed = buffer.subarray(0, bytesToConsume);
      var remaining = buffer.subarray(bytesToConsume);
      return [consumed, remaining];
    }
  }]);
}();
;// CONCATENATED MODULE: external "buffer"
var external_buffer_x = function(y) {
	var x = {}; __lib_require__.d(x, y); return x
} 
var external_buffer_y = function(x) { return function() { return x; }; }
var external_buffer_namespaceObject = external_buffer_x({ ["Blob"]: function() { return __WEBPACK_EXTERNAL_MODULE_buffer__.Blob; } });
;// CONCATENATED MODULE: ./src/private/UploadManagerFetchUtils.ts
function UploadManagerFetchUtils_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function UploadManagerFetchUtils_typeof(o) { "@babel/helpers - typeof"; return UploadManagerFetchUtils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, UploadManagerFetchUtils_typeof(o); }
function UploadManagerFetchUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UploadManagerFetchUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UploadManagerFetchUtils_toPropertyKey(descriptor.key), descriptor); } }
function UploadManagerFetchUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) UploadManagerFetchUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) UploadManagerFetchUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UploadManagerFetchUtils_toPropertyKey(t) { var i = UploadManagerFetchUtils_toPrimitive(t, "string"); return "symbol" == UploadManagerFetchUtils_typeof(i) ? i : i + ""; }
function UploadManagerFetchUtils_toPrimitive(t, r) { if ("object" != UploadManagerFetchUtils_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != UploadManagerFetchUtils_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var UploadManagerFetchUtils = /*#__PURE__*/function () {
  function UploadManagerFetchUtils() {
    UploadManagerFetchUtils_classCallCheck(this, UploadManagerFetchUtils);
  }
  return UploadManagerFetchUtils_createClass(UploadManagerFetchUtils, null, [{
    key: "doPutUploadPart",
    value: function doPutUploadPart(config, part, content, contentLength, addCancellationHandler) {
      try {
        var _a;
        var fetchApi = BytescaleApiClientConfigUtils.getFetchApi(config);
        // Configure cancellation:
        var controller = new AbortController();
        var signal = controller.signal;
        addCancellationHandler(function () {
          return controller.abort();
        });
        var headers = {
          // Required to prevent fetch using "Transfer-Encoding: Chunked" when body is a stream.
          "content-length": contentLength.toString()
        };
        return UploadManagerFetchUtils_await(fetchApi(part.uploadUrl, {
          method: "PUT",
          headers: headers,
          body: content,
          signal: signal,
          cache: "no-store" // Required for Next.js's Fetch implementation, which caches POST/PUT requests by default.
        }), function (response) {
          return {
            etag: (_a = response.headers.get("etag")) !== null && _a !== void 0 ? _a : undefined,
            status: response.status
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}();
;// CONCATENATED MODULE: ./src/public/node/UploadManagerNode.ts
function UploadManagerNode_typeof(o) { "@babel/helpers - typeof"; return UploadManagerNode_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, UploadManagerNode_typeof(o); }
function UploadManagerNode_empty() {}
function UploadManagerNode_awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(UploadManagerNode_empty) : Promise.resolve();
  }
}
function UploadManagerNode_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function UploadManagerNode_settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof UploadManagerNode_Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }
        value = value.v;
      } else {
        value.o = UploadManagerNode_settle.bind(null, pact, state);
        return;
      }
    }
    if (value && value.then) {
      value.then(UploadManagerNode_settle.bind(null, pact, state), UploadManagerNode_settle.bind(null, pact, 2));
      return;
    }
    pact.s = state;
    pact.v = value;
    var observer = pact.o;
    if (observer) {
      observer(pact);
    }
  }
}
var UploadManagerNode_Pact = /*#__PURE__*/function () {
  function _Pact() {}
  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;
    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;
      if (callback) {
        try {
          UploadManagerNode_settle(result, 1, callback(this.v));
        } catch (e) {
          UploadManagerNode_settle(result, 2, e);
        }
        return result;
      } else {
        return this;
      }
    }
    this.o = function (_this) {
      try {
        var value = _this.v;
        if (_this.s & 1) {
          UploadManagerNode_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          UploadManagerNode_settle(result, 1, onRejected(value));
        } else {
          UploadManagerNode_settle(result, 2, value);
        }
      } catch (e) {
        UploadManagerNode_settle(result, 2, e);
      }
    };
    return result;
  };
  return _Pact;
}();
function _switch(discriminant, cases) {
  var dispatchIndex = -1;
  var awaitBody;
  outer: {
    for (var i = 0; i < cases.length; i++) {
      var test = cases[i][0];
      if (test) {
        var testValue = test();
        if (testValue && testValue.then) {
          break outer;
        }
        if (testValue === discriminant) {
          dispatchIndex = i;
          break;
        }
      } else {
        // Found the default case, set it as the pending dispatch case
        dispatchIndex = i;
      }
    }
    if (dispatchIndex !== -1) {
      do {
        var body = cases[dispatchIndex][1];
        while (!body) {
          dispatchIndex++;
          body = cases[dispatchIndex][1];
        }
        var result = body();
        if (result && result.then) {
          awaitBody = true;
          break outer;
        }
        var fallthroughCheck = cases[dispatchIndex][2];
        dispatchIndex++;
      } while (fallthroughCheck && !fallthroughCheck());
      return result;
    }
  }
  var pact = new UploadManagerNode_Pact();
  var reject = UploadManagerNode_settle.bind(null, pact, 2);
  (awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);
  return pact;
  function _resumeAfterTest(value) {
    for (;;) {
      if (value === discriminant) {
        dispatchIndex = i;
        break;
      }
      if (++i === cases.length) {
        if (dispatchIndex !== -1) {
          break;
        } else {
          UploadManagerNode_settle(pact, 1, result);
          return;
        }
      }
      test = cases[i][0];
      if (test) {
        value = test();
        if (value && value.then) {
          value.then(_resumeAfterTest).then(void 0, reject);
          return;
        }
      } else {
        dispatchIndex = i;
      }
    }
    do {
      var body = cases[dispatchIndex][1];
      while (!body) {
        dispatchIndex++;
        body = cases[dispatchIndex][1];
      }
      var result = body();
      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
        return;
      }
      var fallthroughCheck = cases[dispatchIndex][2];
      dispatchIndex++;
    } while (fallthroughCheck && !fallthroughCheck());
    UploadManagerNode_settle(pact, 1, result);
  }
  function _resumeAfterBody(result) {
    for (;;) {
      var fallthroughCheck = cases[dispatchIndex][2];
      if (!fallthroughCheck || fallthroughCheck()) {
        break;
      }
      dispatchIndex++;
      var body = cases[dispatchIndex][1];
      while (!body) {
        dispatchIndex++;
        body = cases[dispatchIndex][1];
      }
      result = body();
      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
        return;
      }
    }
    UploadManagerNode_settle(pact, 1, result);
  }
}
function UploadManagerNode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UploadManagerNode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UploadManagerNode_toPropertyKey(descriptor.key), descriptor); } }
function UploadManagerNode_createClass(Constructor, protoProps, staticProps) { if (protoProps) UploadManagerNode_defineProperties(Constructor.prototype, protoProps); if (staticProps) UploadManagerNode_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UploadManagerNode_toPropertyKey(t) { var i = UploadManagerNode_toPrimitive(t, "string"); return "symbol" == UploadManagerNode_typeof(i) ? i : i + ""; }
function UploadManagerNode_toPrimitive(t, r) { if ("object" != UploadManagerNode_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != UploadManagerNode_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function UploadManagerNode_callSuper(t, o, e) { return o = UploadManagerNode_getPrototypeOf(o), UploadManagerNode_possibleConstructorReturn(t, UploadManagerNode_isNativeReflectConstruct() ? Reflect.construct(o, e || [], UploadManagerNode_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function UploadManagerNode_possibleConstructorReturn(self, call) { if (call && (UploadManagerNode_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return UploadManagerNode_assertThisInitialized(self); }
function UploadManagerNode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function UploadManagerNode_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (UploadManagerNode_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function UploadManagerNode_getPrototypeOf(o) { UploadManagerNode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return UploadManagerNode_getPrototypeOf(o); }
function UploadManagerNode_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) UploadManagerNode_setPrototypeOf(subClass, superClass); }
function UploadManagerNode_setPrototypeOf(o, p) { UploadManagerNode_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return UploadManagerNode_setPrototypeOf(o, p); }






var UploadManager = /*#__PURE__*/function (_UploadManagerBase) {
  function UploadManager() {
    UploadManagerNode_classCallCheck(this, UploadManager);
    return UploadManagerNode_callSuper(this, UploadManager, arguments);
  }
  UploadManagerNode_inherits(UploadManager, _UploadManagerBase);
  return UploadManagerNode_createClass(UploadManager, [{
    key: "processUploadSource",
    value: function processUploadSource(data) {
      if (typeof data === "string") {
        // 'Blob' must be from 'buffer' as we're in a node context here, so isn't globally available.
        return {
          type: "Blob",
          value: new external_buffer_namespaceObject.Blob([data], {
            type: this.stringMimeType
          })
        };
      }
      if (data.on !== undefined) {
        return {
          type: "Stream",
          value: new NodeChunkedStream(data)
        };
      }
      if (data.subarray !== undefined) {
        return {
          type: "Buffer",
          value: data
        };
      }
      if (data.byteLength !== undefined) {
        return {
          type: "ArrayBuffer",
          value: data
        };
      }
      if (data.size !== undefined) {
        return {
          type: "Blob",
          value: data
        };
      }
      throw new Error("Unsupported type for 'data' parameter. Please provide a String, Blob, Buffer, ArrayBuffer, or ReadableStream (Node.js).");
    }
  }, {
    key: "getPreUploadInfoPartial",
    value: function getPreUploadInfoPartial(request, data) {
      switch (data.type) {
        case "Blob":
          return this.getBlobInfo(data);
        case "Buffer":
        case "ArrayBuffer":
          return {
            mime: undefined,
            size: data.value.byteLength,
            originalFileName: undefined,
            maxConcurrentUploadParts: undefined
          };
        case "Stream":
          if (request.size === undefined) {
            throw new Error("You must include the 'size' parameter when using a stream for the 'data' parameter.");
          }
          return {
            mime: undefined,
            size: request.size,
            originalFileName: undefined,
            maxConcurrentUploadParts: 1 // Uploading from a stream concurrently is complex, so we serialize it.
          };
        default:
          assertUnreachable(data);
      }
    }
  }, {
    key: "preUpload",
    value: function preUpload(source) {
      if (source.type !== "Stream") {
        return undefined;
      }
      var chunkedStream = source.value;
      var chunkedStreamPromise = chunkedStream.runChunkPipeline();
      return {
        chunkedStreamPromise: chunkedStreamPromise,
        chunkedStream: chunkedStream
      };
    }
  }, {
    key: "postUpload",
    value: function postUpload(init) {
      try {
        if (init === undefined) {
          return UploadManagerNode_await();
        }
        init.chunkedStream.finishedConsuming();
        // Raise any errors from the stream chunking task.
        return UploadManagerNode_await(UploadManagerNode_awaitIgnored(init.chunkedStreamPromise));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "doPutUploadPart",
    value: function doPutUploadPart(part, contentLength, source, onProgress, addCancellationHandler) {
      try {
        var _this = this;
        // Report progress:
        var hasWarned = false;
        var bytesSent = 0;
        return UploadManagerNode_await(_this.sliceDataForRequest(source, part), function (stream) {
          var streamWithProgress = stream.on("data", function (data) {
            if (data.byteLength !== undefined) {
              bytesSent += data.byteLength;
              onProgress(bytesSent);
            } else if (!hasWarned) {
              hasWarned = true;
              console.warn("Expected stream to contain buffers, but it did not, so upload progress won't be reported.");
            }
          });
          return UploadManagerNode_await(UploadManagerFetchUtils.doPutUploadPart(_this.config, part, _this.coerceRequestBody(streamWithProgress), contentLength, addCancellationHandler));
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "coerceRequestBody",
    value: function coerceRequestBody(data) {
      return data; // node-fetch supports 'NodeJS.ReadableStream'
    }
  }, {
    key: "sliceDataForRequest",
    value: function sliceDataForRequest(data, part) {
      try {
        if (part.range.inclusiveEnd === -1) {
          return UploadManagerNode_await(StreamUtils.empty());
        }
        var start = part.range.inclusiveStart;
        var endExclusive = part.range.inclusiveEnd + 1;
        var partSize = endExclusive - start;
        return UploadManagerNode_await(_switch(data.type, [[function () {
          return "Blob";
        }, function () {
          var _fromArrayBuffer = StreamUtils.fromArrayBuffer;
          return UploadManagerNode_await(data.value.slice(start, endExclusive).arrayBuffer(), function (_data$value$slice$arr) {
            return _fromArrayBuffer.call(StreamUtils, _data$value$slice$arr);
          });
        }], [function () {
          return "ArrayBuffer";
        }, function () {
          return StreamUtils.fromArrayBuffer(data.value.slice(start, endExclusive));
        }], [function () {
          return "Buffer";
        }, function () {
          return StreamUtils.fromBuffer(data.value.subarray(start, endExclusive));
        }], [function () {
          return "Stream";
        }, function () {
          return data.value.take(partSize);
        }], [void 0, function () {
          assertUnreachable(data);
        }, UploadManagerNode_empty]]));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
}(UploadManagerBase);
;// CONCATENATED MODULE: ./src/private/EnvChecker.ts
function EnvChecker_typeof(o) { "@babel/helpers - typeof"; return EnvChecker_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, EnvChecker_typeof(o); }
function EnvChecker_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function EnvChecker_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, EnvChecker_toPropertyKey(descriptor.key), descriptor); } }
function EnvChecker_createClass(Constructor, protoProps, staticProps) { if (protoProps) EnvChecker_defineProperties(Constructor.prototype, protoProps); if (staticProps) EnvChecker_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function EnvChecker_toPropertyKey(t) { var i = EnvChecker_toPrimitive(t, "string"); return "symbol" == EnvChecker_typeof(i) ? i : i + ""; }
function EnvChecker_toPrimitive(t, r) { if ("object" != EnvChecker_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != EnvChecker_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var EnvChecker = /*#__PURE__*/function () {
  function EnvChecker() {
    EnvChecker_classCallCheck(this, EnvChecker);
  }
  return EnvChecker_createClass(EnvChecker, null, [{
    key: "isBrowser",
    value: function isBrowser() {
      return typeof window !== "undefined";
    }
  }, {
    key: "methodRequiresBrowser",
    value: function methodRequiresBrowser(methodName) {
      if (!EnvChecker.isBrowser()) {
        return new Error("You must call '".concat(methodName, "' in your client-side code. (You have called it in your server-side code.)"));
      }
      return new Error("The '".concat(methodName, "' method cannot be called because you have bundled a non-browser implementation of the Bytescale JavaScript SDK into your client-side code. Please ensure your bundling tool (Webpack, Rollup, etc.) is honouring the \"browser\" field of the \"package.json\" file for this package, as this will allow the browser implementation of the Bytescale JavaScript SDK to be included in your client-side code."));
    }
  }]);
}();
;// CONCATENATED MODULE: ./src/public/node/AuthManagerNode.ts
function AuthManagerNode_typeof(o) { "@babel/helpers - typeof"; return AuthManagerNode_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, AuthManagerNode_typeof(o); }
function AuthManagerNode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function AuthManagerNode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, AuthManagerNode_toPropertyKey(descriptor.key), descriptor); } }
function AuthManagerNode_createClass(Constructor, protoProps, staticProps) { if (protoProps) AuthManagerNode_defineProperties(Constructor.prototype, protoProps); if (staticProps) AuthManagerNode_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function AuthManagerNode_toPropertyKey(t) { var i = AuthManagerNode_toPrimitive(t, "string"); return "symbol" == AuthManagerNode_typeof(i) ? i : i + ""; }
function AuthManagerNode_toPrimitive(t, r) { if ("object" != AuthManagerNode_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != AuthManagerNode_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var AuthManagerImpl = /*#__PURE__*/function () {
  function AuthManagerImpl() {
    AuthManagerNode_classCallCheck(this, AuthManagerImpl);
  }
  return AuthManagerNode_createClass(AuthManagerImpl, [{
    key: "beginAuthSession",
    value: function beginAuthSession(_params) {
      try {
        throw EnvChecker.methodRequiresBrowser("beginAuthSession");
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "endAuthSession",
    value: function endAuthSession() {
      try {
        throw EnvChecker.methodRequiresBrowser("endAuthSession");
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "isAuthSessionActive",
    value: function isAuthSessionActive() {
      return false;
    }
  }, {
    key: "isAuthSessionReady",
    value: function isAuthSessionReady() {
      return false;
    }
  }]);
}();
/**
 * Alternative way of implementing a static class (i.e. all methods static). We do this so we can use a interface on the class (interfaces can't define static methods).
 */
var AuthManager = new AuthManagerImpl();
;// CONCATENATED MODULE: ./src/public/node/index.ts


;// CONCATENATED MODULE: ./src/index.node.ts
/* tslint:disable */
/* eslint-disable */


var __lib_exports__AuthManager = __lib_exports__.AuthManager;
var __lib_exports__BaseAPI = __lib_exports__.BaseAPI;
var __lib_exports__BinaryResult = __lib_exports__.BinaryResult;
var __lib_exports__BytescaleApiClientConfigUtils = __lib_exports__.BytescaleApiClientConfigUtils;
var __lib_exports__BytescaleApiError = __lib_exports__.BytescaleApiError;
var __lib_exports__BytescaleGenericError = __lib_exports__.BytescaleGenericError;
var __lib_exports__CacheApi = __lib_exports__.CacheApi;
var __lib_exports__CancelledError = __lib_exports__.CancelledError;
var __lib_exports__CommonTypesNoOp = __lib_exports__.CommonTypesNoOp;
var __lib_exports__FileApi = __lib_exports__.FileApi;
var __lib_exports__FolderApi = __lib_exports__.FolderApi;
var __lib_exports__JSONApiResponse = __lib_exports__.JSONApiResponse;
var __lib_exports__JobApi = __lib_exports__.JobApi;
var __lib_exports__UploadApi = __lib_exports__.UploadApi;
var __lib_exports__UploadManager = __lib_exports__.UploadManager;
var __lib_exports__UrlBuilder = __lib_exports__.UrlBuilder;
var __lib_exports__UrlBuilderTypesNoOp = __lib_exports__.UrlBuilderTypesNoOp;
var __lib_exports__VoidApiResponse = __lib_exports__.VoidApiResponse;
var __lib_exports__encodeBytescaleQuerystringKVP = __lib_exports__.encodeBytescaleQuerystringKVP;
var __lib_exports__querystring = __lib_exports__.querystring;
export { __lib_exports__AuthManager as AuthManager, __lib_exports__BaseAPI as BaseAPI, __lib_exports__BinaryResult as BinaryResult, __lib_exports__BytescaleApiClientConfigUtils as BytescaleApiClientConfigUtils, __lib_exports__BytescaleApiError as BytescaleApiError, __lib_exports__BytescaleGenericError as BytescaleGenericError, __lib_exports__CacheApi as CacheApi, __lib_exports__CancelledError as CancelledError, __lib_exports__CommonTypesNoOp as CommonTypesNoOp, __lib_exports__FileApi as FileApi, __lib_exports__FolderApi as FolderApi, __lib_exports__JSONApiResponse as JSONApiResponse, __lib_exports__JobApi as JobApi, __lib_exports__UploadApi as UploadApi, __lib_exports__UploadManager as UploadManager, __lib_exports__UrlBuilder as UrlBuilder, __lib_exports__UrlBuilderTypesNoOp as UrlBuilderTypesNoOp, __lib_exports__VoidApiResponse as VoidApiResponse, __lib_exports__encodeBytescaleQuerystringKVP as encodeBytescaleQuerystringKVP, __lib_exports__querystring as querystring };
