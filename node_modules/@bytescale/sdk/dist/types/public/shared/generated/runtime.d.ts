import { ErrorResponse } from "./models";
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
export interface BytescaleApiClientConfig {
    /**
     * Only required for Node.js. Must be an instance of requires("node-fetch").
     *
     * Not required for the browser.
     */
    fetchApi?: FetchAPI;
    /**
     * Must begin with "public_" or "secret_".
     *
     * Please note: if you require JWT-based auth, you must provide an API key to this field, and then call 'AuthManager.beginAuthSession' to start a JWT-based auth session. The JWT's permissions will be merged with the API key's permissions, with precedence given to the JWT.
     */
    apiKey: string;
    /**
     * The base URL of the Bytescale API. (Excludes trailing "/".)
     */
    apiUrl?: string;
    /**
     * The base URL of the Bytescale CDN. (Excludes trailing "/".)
     */
    cdnUrl?: string;
    /**
     * Enables additional debug information.
     */
    debug?: boolean;
    /**
     * Headers to include in all API requests.
     *
     * These headers take precedence over any headers automatically added by the SDK (e.g. "Authorization", "Content-Type", etc.).
     */
    headers?: HTTPHeaders | (() => Promise<HTTPHeaders> | HTTPHeaders);
}
export declare class BytescaleApiClientConfigUtils {
    static defaultApiUrl: string;
    static defaultCdnUrl: string;
    private static readonly specialApiKeys;
    private static readonly specialApiKeyAccountId;
    private static readonly accountIdLength;
    static getApiUrl(config: BytescaleApiClientConfig): string;
    static getCdnUrl(config: Pick<BytescaleApiClientConfig, "cdnUrl">): string;
    static getFetchApi(config: Pick<BytescaleApiClientConfig, "fetchApi">): FetchAPI;
    static getAccountId(config: Pick<BytescaleApiClientConfig, "apiKey">): string;
    static validate(config: BytescaleApiClientConfig): void;
}
/**
 * This is the base class for all generated API classes.
 */
export declare class BaseAPI {
    protected readonly config: BytescaleApiClientConfig;
    constructor(config: BytescaleApiClientConfig);
    /**
     * Returns a successful response (2**) else throws an error.
     */
    static fetch(url: string, init: RequestInit, config: Pick<BytescaleApiClientConfig, "fetchApi" | "debug"> & {
        isBytescaleApi: boolean;
    }): Promise<Response>;
    protected request(context: RequestOpts, initOverrides: RequestInit | InitOverrideFunction | undefined, baseUrlOverride: string | undefined): Promise<Response>;
    protected encodeParam(paramName: string, paramValue: string): string;
    private createFetchParams;
}
export declare class CancelledError extends Error {
    name: "CancelledError";
    constructor();
}
/**
 * Thrown when the Bytescale API cannot be reached or when an error is returned that cannot be parsed as a JSON error response.
 */
export declare class BytescaleGenericError extends Error {
    readonly response: Response;
    readonly responseText: string | undefined;
    readonly responseJson: object | undefined;
    name: "BytescaleGenericError";
    constructor(response: Response, responseText: string | undefined, responseJson: object | undefined);
}
/**
 * Thrown when the Bytescale API returns a JSON error response.
 */
export declare class BytescaleApiError extends Error {
    name: "BytescaleApiError";
    readonly errorCode: string;
    readonly details: any | undefined;
    constructor(response: ErrorResponse);
}
export type FetchAPI = WindowOrWorkerGlobalScope["fetch"];
export type Json = any;
export type HTTPMethod = "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "OPTIONS" | "HEAD";
export type HTTPHeaders = {
    [key: string]: string;
};
export type HTTPQuery = {
    [key: string]: string | number | null | boolean | HTTPQuery;
};
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = {
    headers?: HTTPHeaders;
    method: HTTPMethod;
    body?: HTTPBody;
};
export type InitOverrideFunction = (requestContext: {
    init: HTTPRequestInit;
    context: RequestOpts;
}) => Promise<RequestInit>;
export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}
export declare function querystring(params: HTTPQuery): string;
/**
 * Handles artifacts specially as these must use "/" instead of "%2F" in order for relative paths within the artifact's
 * contents to work (assumes user has replaced "?" with "!"). For example, M3U8 artifacts that contain relative URLs to
 * other M3U8s and/or media segments will only work if the user replaces "?" with "!" in the URL _and_ the artifact
 * query param value has been written using "/" instead of "%2F", as this then means the URLs become relative to the
 * artifact, as opposed to the file path.
 */
export declare function encodeBytescaleQuerystringKVP(key: string, value: string): string;
export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}
export declare class JSONApiResponse<T> {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<T>;
}
export declare class VoidApiResponse {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<void>;
}
export declare class BinaryResult {
    raw: Response;
    constructor(raw: Response);
    stream(): ReadableStream<Uint8Array>;
    text(): Promise<string>;
    blob(): Promise<Blob>;
    json(): Promise<any>;
}
